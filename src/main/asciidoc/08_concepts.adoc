[[section-concepts]]
== Concepts

=== Domain Models

_biking2_ is datacentric application, therefore everything is based around an Entity Relationship Diagram (ER-Diagram):

image::8.1_er-diagram.png[align="center"]

[cols="1,2" options="header"]
.Tables
|===
| Name | Description
| bikes | Stores the bikes. Contains dates when the bike was bought and decomissioned, an optional link, color for the charts and also an auditing column when a row was created.
| milages | Stores milages for a bike (when and how much)
| tracks | Stores GPS tracks recorded and uploaded with an optional description. For each day the track names must be unique. The columns _minlat_, _minlon_, _maxlat_ and _maxlon_ store the encapsulating rectangle for the track. The _type_ column is constrainted to "biking" and "running".
| assorted_trips | Stores a date and a distance on that day. Multiple distances per day are allowed.
| locations | Stores arbitrary locations (latitude and longitude based) for given timestamp with an optional description.
| biking_pictures | Stores pictures collected from _Daily Fratze_ together with their original date of publication, their unique external id and a link to the page the picture originaly appeared.
| gallery_pictures | Stores all pictures uploaded by the user with a description and the date the picture was taken. The _filename_ column contains a single, computed filename without path information.
|===

Those tables are mapped to the following domain model:

image::8.1_domain-model.png[align="center"]

[cols="1,2" options="header"]
.Domain model
|===
| Name | Description
| BikeEntity | A bike was bought on a given date and can be decommisioned. It has a color and an optional link to an arbitrary website. It may or may not have milages recorded. It has some important functions, see <<BikingEntityMethods,Important business methods on BikeEntity>>
| MilageEntity | A milage is part of a bike. For each bike one milage per month can be recored. The milage is the combination of it's recording date, the amount and the bike.
| TrackEntity | The representation of _tracks_ contents. The type is an enumeration. Notable public operations are `getPrettyId` (computes a "pretty" id based on the instances id) and `getTrackFile` (generates a reference to the GPS track file in the passed data storage directory).
| BikingPictureEntity | For handling pictures collected from _Daily Fratze_. The BikingPictureEntity parses the image link on construction the retrieve the unique, external id.
| GalleryPictureEntity | A bean for handling the pictures uploaded by the user. `prePersist` fills the `createdAt` attribute prior to inserting into the database.
| AssortedTripEntity | This entity captures a distance which was covered on at a certain date and can used for keeping track on trips with bikes not stored in this application for example.
| LocationEntity | Used in the tracker module for working with real time locations.
|===

[cols="1,2" options="header"]
.Important business methods on BikeEntity
[[BikingEntityMethods]]
|===
| Name | Description
| `decommission` | Decommissions a bike on a given date.
| `addMilage` | Adds a new milage for a given date and returns it. The milage will only be added if the date is after the date the last milage was added and if the amount is greater than the last milage.
| `getPeriods` | Gets all monthly periods in which milages have been recorded.
| `getMilage` | Gets the total milage of this bike.
| `getLastMilage` | Gets the last milage recorded. In most cases the same as `getMilage`.
| `getMilageInPeriod` | Gets the milage in a given period.
| `getMilagesInYear` | Gets all milages in a year as an array (of months).
| `getMilageInYear` | Gets the total milage in a given year.
|===

=== Recurring or Generic Structures and Patterns

[role="arc42help"]
****
.Motivation
Sometimes a hierarchical decomposition of building blocks is insufficient for giving an overview of detailed interdependencies between individual building blocks. The following sections are intended to describe generic or specific dependencies among any set of building blocks – possibly even across different levels.
We call a dependency *generic* if it appears more than once in the architecture, and *specific*if it is unique.

.Form
Use building block models (class diagrams, package diagrams, component diagrams, etc.) and related descriptions in the same way as in the hierarchical decomposition.
Often it is practical to support understandability by adding specific
runtime views to explain these recurring structures.
****

==== Recurring or Generic Structure 1

<insert diagram and descriptions here>

==== Recurring or Generic Structure 2

<insert diagram and descriptions here>

=== Persistency

_biking2_ uses an http://www.h2database.com/html/main.html[H2] database for storing relational data and the file system for binary image files and large ascii files (especially all GPS files).

During development and production the H2 database is retained and not in-memory based. The location of this file is configured through the `biking2.database-file` property and the default during development is `./var/dev/db/biking-dev` relative to the working directory of the VM.

All access to the database goes through JPA using Hibernate as provider. See the <<Domain Models>> for all entities used in the application.

The JPA Entity Manager isn't accessed directly but only through the facilities offered by Spring Data JPA, that is through repositories only.

All data stored as files is stored relative to `biking2.datastore-base-directory` which defaults to `./var/dev`. Inside are 3 directories:

* `bikingPictures`: Contains all pictures collected from _Daily Fratze_
* `galleryPictures`: Contains all uploaded pictures
* `tracks`: Contains uploaded GPS data and the result of converting TCX files into GPX files

=== User Interface

[role="arc42help"]
****
Software systems that are used interactively by (human) users require a user interface. These can be graphical, textual, or voice user interfaces.
****

=== Ergonomics

[role="arc42help"]
****
Ergonomics of software systems deals with the improvement (optimization) of their usability with respect to objective and subjective factors. Key ergonomic factors are user interface, reactivity (subjective performance) as well as availability and robustness of the system.
****

=== Flow of Control

[role="arc42help"]
****
Flow of control for software systems is related to visible flows (on the - graphical - user interface) as well as the flow of background activities. Therefore this section should cover control of the user interface as well as control of workflows.
****

=== Transaction Processing

[role="arc42help"]
****
A transaction is a sets of operations or activities that must be processed either in its entirety or not at all. The term is especially relevant in the database area with the important notion of ACID-transactions (atomic, consistent, isolated, durable).
****

=== Session Handling

[role="arc42help"]
****
A session identifies an active connection between a client and a server. The session state must be preserved, which is esp. important if stateless protocols such as HTTP are used for communications. Session handling is a critical challenge esp. for intra- and internet-systems and can strongly influence the performance of a system.
****

=== Security

[role="arc42help"]
****
The security of software systems deals with mechanisms that ensure data confidentiality, integrity, and availability.

Typical issues are:

* How can data be protected during transport (e.g. via open networks such as the internet)?
* How can communicating entities ensure mutual trust?
* How can communicating entities identify each other and be protected against faked identities?
* How can communicating entities prove data provenience or certify validity of data?

The topic of IT-security often touches upon legal aspects, sometimes even international law.
****

=== Safety

[role="arc42help"]
****
The safety of software systems deals with mechanisms that ensure that human life or our environment is not endangered.
Describe your concept here: identify those parts of the system that might endanger life and describe mechanism to ensure proper safety.
****

=== Communications and Integration


[role="arc42help"]
****
*Communication*: Exchange of data between system components. Covers communications within one process or address space, between different processes (inter-process communication – IPC), and between different systems.

*Integration*: Combination of existing systems in a new context. Also known as: (Legacy) Wrapper, Gateway, Enterprise Application Integration (EAI).
****

=== Distribution

[role="arc42help"]
****
**Distribution**: Design of software systems whose parts are executed on different – physically separated – hardware systems.

Distribution covers issues such as calling methods on remote systems (remote procedure call – RPC or remote method invocation – RMI), the transfer of data or documents among distributed parties, the choice of optimal modes of interaction or communications patterns (such as synchronous / asynchronous, publish-subscribe, peer-to-peer).
****

=== Plausibility and Validity Checks

[role="arc42help"]
****
How and where do you check plausibility and validity of (input) data, esp. user inputs?
****

=== Exception/Error Handling

[role="arc42help"]
****
How are exceptions and errors handled systematically and consistently?

How can the system reach a consistent state after an error? Is this done automatically or is manual interaction required?

This aspect is also related to logging and tracing,

Which kind of exceptions and errors are handled by the system? Which kinds of errors are forwarded to which external interface and which are handled fully internally?

How do you use the exception handling mechanisms of your programming language? Do you use checked or unchecked exceptions?
****

=== System Management and Administration

[role="arc42help"]
****
Larger software systems are often executed in controlled environments (data centers) under oversight of operators or administrators. These stakeholders require specific information on the applications’ states during runtime as well as special means of control and configuration.
****

=== Logging, Tracing

[role="arc42help"]
****
There are two ways of documenting an application’s status during runtime: *Logging* and *Tracing*. In both cases the application is extended with function or method calls that write state information, but there is a difference in their usage:

* Logging can cover business or technical aspects or any combination of both.
* Business logs are normally prepared for end users, administrators or operators. They contain information on the business processes that are executed by the application. This kind of logging may also be related to auditing.
* Technical logs contain information for operators or developers. These are used for error detection and system optimization.
* Tracing is intended to provide debugging information for developers or support personnel. It is primarily used for error detection and analysis.
****

=== Business Rules

[role="arc42help"]
****
How do you deal with business logic and business rules? Is business logic implemented in the corresponding business classes or is it handled in a central component? Do you use a rule engine for the interpretation of business rules (production system, forward-/backward-chaining)?
****

=== Configurability

[role="arc42help"]
****
The flexibility of a software system is influenced by its configurability, i.e. the possibility to make certain decisions about usage of the system at a late point in time.

Configurability can occur at the following events:

* During development: For example server, file, or directory names could be stored directly in the code (“hard-coded”).
* During deployment or installation: Configuration information for a specific installation (such as the installation path) can be given.
* At system startup: Information can be read dynamically before or during system startup.
* During application execution: Configuration information is queried or read during runtime.
****

=== Parallelization and Threading

[role="arc42help"]
****
Applications can be executed in parallel processes or threads. This creates a need for synchronization points. The theory of parallel processing serves as a foundation for this aspect. The architecture and implementation of parallel systems needs to consider many technical details such as address spaces, applied mechanisms for synchronization –
guards, semaphores, etc. – processes and threads, parallelism in the operating system, parallelism in virtual machines. etc.
****

=== Internationalization

[role="arc42help"]
****
This section covers support for usage of the system in different countries, i.e. adjusting the system to country specific attributes. Internationalization (often abbreviated as “i18n” where “18” refers to the eighteen characters between the I and the n) covers translation of text, usage of character encodings, display of fonts, writing of numbers and dates, and other (external) aspects.
****

=== Migration

[role="arc42help"]
****
In many cases a new software system is intended to replace an existing legacy system. As an architect you should not only consider your shiny new architecture but also all organizational and technical aspects that must be considered for the introduction or migration of the architecture.

.Examples:

* Concept, process, or tools for data transfer and initial data creation.
* Concept for system introduction or temporary parallel operations of legacy system and new system.

Is it necessary to migrate existing data? How do you execute any needed syntactic or semantic transformations?
****

=== Testability

[role="arc42help"]
****
Support for simple (and if possible automated) tests. This aspect is the basis for the important implementation pattern of “continuous integration”. Projects should support at least daily build-and-test cycles. Important keywords for this aspect are unit tests and mock objects.
****

=== Scaling, Clustering

[role="arc42help"]
****
How can your system grow in a way that can cope with more load or a larger number of users and still keep up performance and throughput.
****

=== High Availability

[role="arc42help"]
****
How can you achieve high availability of your system? Do you use redundancy of major parts? Or do you distribute your system to different processors or locations. Are you running standby- systems?
****

=== Code Generation

[role="arc42help"]
****
How and where do you use code generators to create parts of the system from models or domain specific languages (DSL’s)?
****

=== Build-Management

[role="arc42help"]
****
How is the overall system created from is (source code) building blocks? Which repositories contain source code, where are configuration files, test cases, test data and build scripts (make, ant, maven) stored?
****
